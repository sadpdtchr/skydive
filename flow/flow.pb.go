//go:generate go run github.com/skydive-project/skydive/scripts/gendecoder
// Code generated by protoc-gen-gogo. DO NOT MODIFY
// source: flow/flow.proto

package flow

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_google_gopacket_layers "github.com/google/gopacket/layers"
	filters "github.com/skydive-project/skydive/filters"
	layers "github.com/skydive-project/skydive/flow/layers"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FlowProtocol int32

const (
	FlowProtocol_ETHERNET FlowProtocol = 0
	FlowProtocol_IPV4     FlowProtocol = 1
	FlowProtocol_TCP      FlowProtocol = 2
	FlowProtocol_UDP      FlowProtocol = 3
	FlowProtocol_SCTP     FlowProtocol = 4
	FlowProtocol_IPV6     FlowProtocol = 5
	FlowProtocol_ICMPV4   FlowProtocol = 6
	FlowProtocol_ICMPV6   FlowProtocol = 7
)

var FlowProtocol_name = map[int32]string{
	0: "ETHERNET",
	1: "IPV4",
	2: "TCP",
	3: "UDP",
	4: "SCTP",
	5: "IPV6",
	6: "ICMPV4",
	7: "ICMPV6",
}

var FlowProtocol_value = map[string]int32{
	"ETHERNET": 0,
	"IPV4":     1,
	"TCP":      2,
	"UDP":      3,
	"SCTP":     4,
	"IPV6":     5,
	"ICMPV4":   6,
	"ICMPV6":   7,
}

func (x FlowProtocol) String() string {
	return proto.EnumName(FlowProtocol_name, int32(x))
}

func (FlowProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{0}
}

type FlowFinishType int32

const (
	FlowFinishType_NOT_FINISHED FlowFinishType = 0
	FlowFinishType_TIMEOUT      FlowFinishType = 1
	FlowFinishType_TCP_FIN      FlowFinishType = 2
	FlowFinishType_TCP_RST      FlowFinishType = 3
)

var FlowFinishType_name = map[int32]string{
	0: "NOT_FINISHED",
	1: "TIMEOUT",
	2: "TCP_FIN",
	3: "TCP_RST",
}

var FlowFinishType_value = map[string]int32{
	"NOT_FINISHED": 0,
	"TIMEOUT":      1,
	"TCP_FIN":      2,
	"TCP_RST":      3,
}

func (x FlowFinishType) String() string {
	return proto.EnumName(FlowFinishType_name, int32(x))
}

func (FlowFinishType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{1}
}

type ICMPType int32

const (
	ICMPType_UNKNOWN                 ICMPType = 0
	ICMPType_DESTINATION_UNREACHABLE ICMPType = 1
	ICMPType_ECHO                    ICMPType = 2
	ICMPType_NEIGHBOR                ICMPType = 3
	ICMPType_ADDRESS_MASK            ICMPType = 4
	ICMPType_INFO                    ICMPType = 5
	ICMPType_PARAMETER_PROBLEM       ICMPType = 6
	ICMPType_REDIRECT                ICMPType = 7
	ICMPType_ROUTER                  ICMPType = 8
	ICMPType_SOURCE_QUENCH           ICMPType = 9
	ICMPType_TIME_EXCEEDED           ICMPType = 10
	ICMPType_TIMESTAMP               ICMPType = 11
	ICMPType_PACKET_TOO_BIG          ICMPType = 12
)

var ICMPType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "DESTINATION_UNREACHABLE",
	2:  "ECHO",
	3:  "NEIGHBOR",
	4:  "ADDRESS_MASK",
	5:  "INFO",
	6:  "PARAMETER_PROBLEM",
	7:  "REDIRECT",
	8:  "ROUTER",
	9:  "SOURCE_QUENCH",
	10: "TIME_EXCEEDED",
	11: "TIMESTAMP",
	12: "PACKET_TOO_BIG",
}

var ICMPType_value = map[string]int32{
	"UNKNOWN":                 0,
	"DESTINATION_UNREACHABLE": 1,
	"ECHO":                    2,
	"NEIGHBOR":                3,
	"ADDRESS_MASK":            4,
	"INFO":                    5,
	"PARAMETER_PROBLEM":       6,
	"REDIRECT":                7,
	"ROUTER":                  8,
	"SOURCE_QUENCH":           9,
	"TIME_EXCEEDED":           10,
	"TIMESTAMP":               11,
	"PACKET_TOO_BIG":          12,
}

func (x ICMPType) String() string {
	return proto.EnumName(ICMPType_name, int32(x))
}

func (ICMPType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{2}
}

// gendecoder
type FlowLayer struct {
	Protocol FlowProtocol `protobuf:"varint,1,opt,name=Protocol,proto3,enum=flow.FlowProtocol" json:"Protocol"`
	A        string       `protobuf:"bytes,3,opt,name=A,proto3" json:"A,omitempty"`
	B        string       `protobuf:"bytes,4,opt,name=B,proto3" json:"B,omitempty"`
	ID       int64        `protobuf:"varint,5,opt,name=ID,proto3" json:"ID"`
}

func (m *FlowLayer) Reset()         { *m = FlowLayer{} }
func (m *FlowLayer) String() string { return proto.CompactTextString(m) }
func (*FlowLayer) ProtoMessage()    {}
func (*FlowLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{0}
}
func (m *FlowLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowLayer.Merge(m, src)
}
func (m *FlowLayer) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FlowLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowLayer.DiscardUnknown(m)
}

var xxx_messageInfo_FlowLayer proto.InternalMessageInfo

func (m *FlowLayer) GetProtocol() FlowProtocol {
	if m != nil {
		return m.Protocol
	}
	return FlowProtocol_ETHERNET
}

func (m *FlowLayer) GetA() string {
	if m != nil {
		return m.A
	}
	return ""
}

func (m *FlowLayer) GetB() string {
	if m != nil {
		return m.B
	}
	return ""
}

func (m *FlowLayer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// gendecoder
type TransportLayer struct {
	Protocol FlowProtocol `protobuf:"varint,1,opt,name=Protocol,proto3,enum=flow.FlowProtocol" json:"Protocol"`
	A        int64        `protobuf:"varint,2,opt,name=A,proto3" json:"A"`
	B        int64        `protobuf:"varint,3,opt,name=B,proto3" json:"B"`
	ID       int64        `protobuf:"varint,4,opt,name=ID,proto3" json:"ID"`
}

func (m *TransportLayer) Reset()         { *m = TransportLayer{} }
func (m *TransportLayer) String() string { return proto.CompactTextString(m) }
func (*TransportLayer) ProtoMessage()    {}
func (*TransportLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{1}
}
func (m *TransportLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransportLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransportLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransportLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransportLayer.Merge(m, src)
}
func (m *TransportLayer) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransportLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TransportLayer.DiscardUnknown(m)
}

var xxx_messageInfo_TransportLayer proto.InternalMessageInfo

func (m *TransportLayer) GetProtocol() FlowProtocol {
	if m != nil {
		return m.Protocol
	}
	return FlowProtocol_ETHERNET
}

func (m *TransportLayer) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *TransportLayer) GetB() int64 {
	if m != nil {
		return m.B
	}
	return 0
}

func (m *TransportLayer) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// gendecoder
type ICMPLayer struct {
	Type ICMPType `protobuf:"varint,1,opt,name=Type,proto3,enum=flow.ICMPType" json:"Type"`
	Code uint32   `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	ID   uint32   `protobuf:"varint,3,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *ICMPLayer) Reset()         { *m = ICMPLayer{} }
func (m *ICMPLayer) String() string { return proto.CompactTextString(m) }
func (*ICMPLayer) ProtoMessage()    {}
func (*ICMPLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{2}
}
func (m *ICMPLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICMPLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICMPLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICMPLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPLayer.Merge(m, src)
}
func (m *ICMPLayer) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ICMPLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPLayer.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPLayer proto.InternalMessageInfo

func (m *ICMPLayer) GetType() ICMPType {
	if m != nil {
		return m.Type
	}
	return ICMPType_UNKNOWN
}

func (m *ICMPLayer) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ICMPLayer) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

// gendecoder
type FlowMetric struct {
	ABPackets int64 `protobuf:"varint,2,opt,name=ABPackets,proto3" json:"ABPackets"`
	ABBytes   int64 `protobuf:"varint,3,opt,name=ABBytes,proto3" json:"ABBytes"`
	BAPackets int64 `protobuf:"varint,4,opt,name=BAPackets,proto3" json:"BAPackets"`
	BABytes   int64 `protobuf:"varint,5,opt,name=BABytes,proto3" json:"BABytes"`
	Start     int64 `protobuf:"varint,6,opt,name=Start,proto3" json:"Start"`
	Last      int64 `protobuf:"varint,7,opt,name=Last,proto3" json:"Last"`
	RTT       int64 `protobuf:"varint,8,opt,name=RTT,proto3" json:"RTT,omitempty"`
}

func (m *FlowMetric) Reset()         { *m = FlowMetric{} }
func (m *FlowMetric) String() string { return proto.CompactTextString(m) }
func (*FlowMetric) ProtoMessage()    {}
func (*FlowMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{3}
}
func (m *FlowMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowMetric.Merge(m, src)
}
func (m *FlowMetric) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FlowMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowMetric.DiscardUnknown(m)
}

var xxx_messageInfo_FlowMetric proto.InternalMessageInfo

func (m *FlowMetric) GetABPackets() int64 {
	if m != nil {
		return m.ABPackets
	}
	return 0
}

func (m *FlowMetric) GetABBytes() int64 {
	if m != nil {
		return m.ABBytes
	}
	return 0
}

func (m *FlowMetric) GetBAPackets() int64 {
	if m != nil {
		return m.BAPackets
	}
	return 0
}

func (m *FlowMetric) GetBABytes() int64 {
	if m != nil {
		return m.BABytes
	}
	return 0
}

func (m *FlowMetric) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FlowMetric) GetLast() int64 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *FlowMetric) GetRTT() int64 {
	if m != nil {
		return m.RTT
	}
	return 0
}

type RawPacket struct {
	Timestamp int64                                      `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp"`
	Index     int64                                      `protobuf:"varint,2,opt,name=Index,proto3" json:"Index"`
	Data      []byte                                     `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	LinkType  github_com_google_gopacket_layers.LinkType `protobuf:"varint,4,opt,name=LinkType,proto3,casttype=github.com/google/gopacket/layers.LinkType" json:"LinkType,omitempty"`
}

func (m *RawPacket) Reset()         { *m = RawPacket{} }
func (m *RawPacket) String() string { return proto.CompactTextString(m) }
func (*RawPacket) ProtoMessage()    {}
func (*RawPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{4}
}
func (m *RawPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawPacket.Merge(m, src)
}
func (m *RawPacket) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RawPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_RawPacket.DiscardUnknown(m)
}

var xxx_messageInfo_RawPacket proto.InternalMessageInfo

func (m *RawPacket) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RawPacket) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *RawPacket) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *RawPacket) GetLinkType() github_com_google_gopacket_layers.LinkType {
	if m != nil {
		return m.LinkType
	}
	return 0
}

// gendecoder
type IPMetric struct {
	Fragments      int64 `protobuf:"varint,1,opt,name=Fragments,proto3" json:"Fragments"`
	FragmentErrors int64 `protobuf:"varint,2,opt,name=FragmentErrors,proto3" json:"FragmentErrors"`
}

func (m *IPMetric) Reset()         { *m = IPMetric{} }
func (m *IPMetric) String() string { return proto.CompactTextString(m) }
func (*IPMetric) ProtoMessage()    {}
func (*IPMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{5}
}
func (m *IPMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPMetric.Merge(m, src)
}
func (m *IPMetric) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IPMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_IPMetric.DiscardUnknown(m)
}

var xxx_messageInfo_IPMetric proto.InternalMessageInfo

func (m *IPMetric) GetFragments() int64 {
	if m != nil {
		return m.Fragments
	}
	return 0
}

func (m *IPMetric) GetFragmentErrors() int64 {
	if m != nil {
		return m.FragmentErrors
	}
	return 0
}

// gendecoder
type TCPMetric struct {
	ABSynStart            int64  `protobuf:"varint,1,opt,name=ABSynStart,proto3" json:"ABSynStart"`
	BASynStart            int64  `protobuf:"varint,2,opt,name=BASynStart,proto3" json:"BASynStart"`
	ABSynTTL              uint32 `protobuf:"varint,3,opt,name=ABSynTTL,proto3" json:"ABSynTTL,omitempty"`
	BASynTTL              uint32 `protobuf:"varint,4,opt,name=BASynTTL,proto3" json:"BASynTTL,omitempty"`
	ABFinStart            int64  `protobuf:"varint,5,opt,name=ABFinStart,proto3" json:"ABFinStart"`
	BAFinStart            int64  `protobuf:"varint,6,opt,name=BAFinStart,proto3" json:"BAFinStart"`
	ABRstStart            int64  `protobuf:"varint,7,opt,name=ABRstStart,proto3" json:"ABRstStart"`
	BARstStart            int64  `protobuf:"varint,8,opt,name=BARstStart,proto3" json:"BARstStart"`
	ABSegmentOutOfOrder   int64  `protobuf:"varint,9,opt,name=ABSegmentOutOfOrder,proto3" json:"ABSegmentOutOfOrder"`
	ABSegmentSkipped      int64  `protobuf:"varint,10,opt,name=ABSegmentSkipped,proto3" json:"ABSegmentSkipped"`
	ABSegmentSkippedBytes int64  `protobuf:"varint,11,opt,name=ABSegmentSkippedBytes,proto3" json:"ABSegmentSkippedBytes"`
	ABPackets             int64  `protobuf:"varint,12,opt,name=ABPackets,proto3" json:"ABPackets"`
	ABBytes               int64  `protobuf:"varint,13,opt,name=ABBytes,proto3" json:"ABBytes"`
	ABSawStart            int64  `protobuf:"varint,14,opt,name=ABSawStart,proto3" json:"ABSawStart"`
	ABSawEnd              int64  `protobuf:"varint,15,opt,name=ABSawEnd,proto3" json:"ABSawEnd"`
	BASegmentOutOfOrder   int64  `protobuf:"varint,16,opt,name=BASegmentOutOfOrder,proto3" json:"BASegmentOutOfOrder"`
	BASegmentSkipped      int64  `protobuf:"varint,17,opt,name=BASegmentSkipped,proto3" json:"BASegmentSkipped"`
	BASegmentSkippedBytes int64  `protobuf:"varint,18,opt,name=BASegmentSkippedBytes,proto3" json:"BASegmentSkippedBytes"`
	BAPackets             int64  `protobuf:"varint,19,opt,name=BAPackets,proto3" json:"BAPackets"`
	BABytes               int64  `protobuf:"varint,20,opt,name=BABytes,proto3" json:"BABytes"`
	BASawStart            int64  `protobuf:"varint,21,opt,name=BASawStart,proto3" json:"BASawStart"`
	BASawEnd              int64  `protobuf:"varint,22,opt,name=BASawEnd,proto3" json:"BASawEnd"`
}

func (m *TCPMetric) Reset()         { *m = TCPMetric{} }
func (m *TCPMetric) String() string { return proto.CompactTextString(m) }
func (*TCPMetric) ProtoMessage()    {}
func (*TCPMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{6}
}
func (m *TCPMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCPMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPMetric.Merge(m, src)
}
func (m *TCPMetric) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TCPMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPMetric.DiscardUnknown(m)
}

var xxx_messageInfo_TCPMetric proto.InternalMessageInfo

func (m *TCPMetric) GetABSynStart() int64 {
	if m != nil {
		return m.ABSynStart
	}
	return 0
}

func (m *TCPMetric) GetBASynStart() int64 {
	if m != nil {
		return m.BASynStart
	}
	return 0
}

func (m *TCPMetric) GetABSynTTL() uint32 {
	if m != nil {
		return m.ABSynTTL
	}
	return 0
}

func (m *TCPMetric) GetBASynTTL() uint32 {
	if m != nil {
		return m.BASynTTL
	}
	return 0
}

func (m *TCPMetric) GetABFinStart() int64 {
	if m != nil {
		return m.ABFinStart
	}
	return 0
}

func (m *TCPMetric) GetBAFinStart() int64 {
	if m != nil {
		return m.BAFinStart
	}
	return 0
}

func (m *TCPMetric) GetABRstStart() int64 {
	if m != nil {
		return m.ABRstStart
	}
	return 0
}

func (m *TCPMetric) GetBARstStart() int64 {
	if m != nil {
		return m.BARstStart
	}
	return 0
}

func (m *TCPMetric) GetABSegmentOutOfOrder() int64 {
	if m != nil {
		return m.ABSegmentOutOfOrder
	}
	return 0
}

func (m *TCPMetric) GetABSegmentSkipped() int64 {
	if m != nil {
		return m.ABSegmentSkipped
	}
	return 0
}

func (m *TCPMetric) GetABSegmentSkippedBytes() int64 {
	if m != nil {
		return m.ABSegmentSkippedBytes
	}
	return 0
}

func (m *TCPMetric) GetABPackets() int64 {
	if m != nil {
		return m.ABPackets
	}
	return 0
}

func (m *TCPMetric) GetABBytes() int64 {
	if m != nil {
		return m.ABBytes
	}
	return 0
}

func (m *TCPMetric) GetABSawStart() int64 {
	if m != nil {
		return m.ABSawStart
	}
	return 0
}

func (m *TCPMetric) GetABSawEnd() int64 {
	if m != nil {
		return m.ABSawEnd
	}
	return 0
}

func (m *TCPMetric) GetBASegmentOutOfOrder() int64 {
	if m != nil {
		return m.BASegmentOutOfOrder
	}
	return 0
}

func (m *TCPMetric) GetBASegmentSkipped() int64 {
	if m != nil {
		return m.BASegmentSkipped
	}
	return 0
}

func (m *TCPMetric) GetBASegmentSkippedBytes() int64 {
	if m != nil {
		return m.BASegmentSkippedBytes
	}
	return 0
}

func (m *TCPMetric) GetBAPackets() int64 {
	if m != nil {
		return m.BAPackets
	}
	return 0
}

func (m *TCPMetric) GetBABytes() int64 {
	if m != nil {
		return m.BABytes
	}
	return 0
}

func (m *TCPMetric) GetBASawStart() int64 {
	if m != nil {
		return m.BASawStart
	}
	return 0
}

func (m *TCPMetric) GetBASawEnd() int64 {
	if m != nil {
		return m.BASawEnd
	}
	return 0
}

type Message struct {
	Flows []*Flow `protobuf:"bytes,1,rep,name=Flows,proto3" json:"Flows,omitempty"`
	Stats *Stats  `protobuf:"bytes,2,opt,name=Stats,proto3" json:"Stats,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{7}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetFlows() []*Flow {
	if m != nil {
		return m.Flows
	}
	return nil
}

func (m *Message) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type Stats struct {
	CaptureID         string `protobuf:"bytes,1,opt,name=CaptureID,proto3" json:"CaptureID,omitempty"`
	FlowCount         int64  `protobuf:"varint,2,opt,name=FlowCount,proto3" json:"FlowCount"`
	FlowDropped       int64  `protobuf:"varint,3,opt,name=FlowDropped,proto3" json:"FlowDropped"`
	KernelFlowDropped int64  `protobuf:"varint,4,opt,name=KernelFlowDropped,proto3" json:"KernelFlowDropped"`
	PacketsDropped    int64  `protobuf:"varint,5,opt,name=PacketsDropped,proto3" json:"PacketsDropped"`
	PacketsReceived   int64  `protobuf:"varint,6,opt,name=PacketsReceived,proto3" json:"PacketsReceived"`
}

func (m *Stats) Reset()         { *m = Stats{} }
func (m *Stats) String() string { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()    {}
func (*Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{8}
}
func (m *Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stats.Merge(m, src)
}
func (m *Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_Stats proto.InternalMessageInfo

func (m *Stats) GetCaptureID() string {
	if m != nil {
		return m.CaptureID
	}
	return ""
}

func (m *Stats) GetFlowCount() int64 {
	if m != nil {
		return m.FlowCount
	}
	return 0
}

func (m *Stats) GetFlowDropped() int64 {
	if m != nil {
		return m.FlowDropped
	}
	return 0
}

func (m *Stats) GetKernelFlowDropped() int64 {
	if m != nil {
		return m.KernelFlowDropped
	}
	return 0
}

func (m *Stats) GetPacketsDropped() int64 {
	if m != nil {
		return m.PacketsDropped
	}
	return 0
}

func (m *Stats) GetPacketsReceived() int64 {
	if m != nil {
		return m.PacketsReceived
	}
	return 0
}

type Flow struct {
	XXX_state flowState `json:"-"`
	// Flow Universally Unique IDentifier
	//flow.UUID is unique in the universe, as it should be used as a key of an
	//hashtable. By design 2 different flows, their UUID are always different.
	//flow.UUID can be used as Database Index.
	UUID       string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	LayersPath string `protobuf:"bytes,2,opt,name=LayersPath,proto3" json:"LayersPath,omitempty"`
	// Application is the last layer which is not a payload.
	Application string `protobuf:"bytes,3,opt,name=Application,proto3" json:"Application,omitempty"`
	// Data Flow info
	Link      *FlowLayer      `protobuf:"bytes,20,opt,name=Link,proto3" json:"Link,omitempty"`
	Network   *FlowLayer      `protobuf:"bytes,21,opt,name=Network,proto3" json:"Network,omitempty"`
	Transport *TransportLayer `protobuf:"bytes,22,opt,name=Transport,proto3" json:"Transport,omitempty"`
	ICMP      *ICMPLayer      `protobuf:"bytes,23,opt,name=ICMP,proto3" json:"ICMP,omitempty"`
	// extra layers
	DHCPv4 *layers.DHCPv4 `protobuf:"bytes,1000,opt,name=DHCPv4,proto3" json:"DHCPv4,omitempty"`
	DNS    *layers.DNS    `protobuf:"bytes,1001,opt,name=DNS,proto3" json:"DNS,omitempty"`
	VRRPv2 *layers.VRRPv2 `protobuf:"bytes,1002,opt,name=VRRPv2,proto3" json:"VRRPv2,omitempty"`
	// Data Flow Metric info from the 1st layer
	//amount of data between two updates
	LastUpdateMetric *FlowMetric `protobuf:"bytes,31,opt,name=LastUpdateMetric,proto3" json:"LastUpdateMetric,omitempty"`
	// Total amount of data for the whole flow duration
	Metric *FlowMetric `protobuf:"bytes,32,opt,name=Metric,proto3" json:"Metric,omitempty"`
	// Metric specific to the TCP and IPs Protocols and optional
	TCPMetric *TCPMetric `protobuf:"bytes,38,opt,name=TCPMetric,proto3" json:"TCPMetric,omitempty"`
	IPMetric  *IPMetric  `protobuf:"bytes,39,opt,name=IPMetric,proto3" json:"IPMetric,omitempty"`
	Start     int64      `protobuf:"varint,10,opt,name=Start,proto3" json:"Start"`
	Last      int64      `protobuf:"varint,11,opt,name=Last,proto3" json:"Last"`
	// Flow Tracking IDentifier, from 1st packet bytes
	//flow.TrackingID could be used to identify an unique flow whatever it has
	//been captured on the infrastructure. flow.TrackingID is calculated from
	//the bytes of the first packet of his session.
	//flow.TrackingID can be used as a Tag.
	TrackingID   string `protobuf:"bytes,50,opt,name=TrackingID,proto3" json:"TrackingID,omitempty"`
	L3TrackingID string `protobuf:"bytes,51,opt,name=L3TrackingID,proto3" json:"L3TrackingID,omitempty"`
	// Flow Parent UUID is used as reference to the parent flow
	//Flow.ParentUUID is the same value that point to his parent flow.UUID
	ParentUUID string `protobuf:"bytes,6,opt,name=ParentUUID,proto3" json:"ParentUUID"`
	// Topology info
	NodeTID string `protobuf:"bytes,33,opt,name=NodeTID,proto3" json:"NodeTID,omitempty"`
	// Capture info
	CaptureID string `protobuf:"bytes,34,opt,name=CaptureID,proto3" json:"CaptureID,omitempty"`
	// raw packets, will not be exported, see Makefile
	LastRawPackets []*RawPacket `protobuf:"bytes,36,rep,name=LastRawPackets,proto3" json:"-"`
	// number of raw packet captured
	RawPacketsCaptured int64 `protobuf:"varint,37,opt,name=RawPacketsCaptured,proto3" json:"RawPacketsCaptured"`
	// describes the way the flow was ended (e.g. by RST, FIN)
	FinishType FlowFinishType `protobuf:"varint,60,opt,name=FinishType,proto3,enum=flow.FlowFinishType" json:"FinishType,omitempty"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{9}
}
func (m *Flow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

func (m *Flow) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *Flow) GetLayersPath() string {
	if m != nil {
		return m.LayersPath
	}
	return ""
}

func (m *Flow) GetApplication() string {
	if m != nil {
		return m.Application
	}
	return ""
}

func (m *Flow) GetLink() *FlowLayer {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *Flow) GetNetwork() *FlowLayer {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Flow) GetTransport() *TransportLayer {
	if m != nil {
		return m.Transport
	}
	return nil
}

func (m *Flow) GetICMP() *ICMPLayer {
	if m != nil {
		return m.ICMP
	}
	return nil
}

func (m *Flow) GetDHCPv4() *layers.DHCPv4 {
	if m != nil {
		return m.DHCPv4
	}
	return nil
}

func (m *Flow) GetDNS() *layers.DNS {
	if m != nil {
		return m.DNS
	}
	return nil
}

func (m *Flow) GetVRRPv2() *layers.VRRPv2 {
	if m != nil {
		return m.VRRPv2
	}
	return nil
}

func (m *Flow) GetLastUpdateMetric() *FlowMetric {
	if m != nil {
		return m.LastUpdateMetric
	}
	return nil
}

func (m *Flow) GetMetric() *FlowMetric {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *Flow) GetTCPMetric() *TCPMetric {
	if m != nil {
		return m.TCPMetric
	}
	return nil
}

func (m *Flow) GetIPMetric() *IPMetric {
	if m != nil {
		return m.IPMetric
	}
	return nil
}

func (m *Flow) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Flow) GetLast() int64 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *Flow) GetTrackingID() string {
	if m != nil {
		return m.TrackingID
	}
	return ""
}

func (m *Flow) GetL3TrackingID() string {
	if m != nil {
		return m.L3TrackingID
	}
	return ""
}

func (m *Flow) GetParentUUID() string {
	if m != nil {
		return m.ParentUUID
	}
	return ""
}

func (m *Flow) GetNodeTID() string {
	if m != nil {
		return m.NodeTID
	}
	return ""
}

func (m *Flow) GetCaptureID() string {
	if m != nil {
		return m.CaptureID
	}
	return ""
}

func (m *Flow) GetLastRawPackets() []*RawPacket {
	if m != nil {
		return m.LastRawPackets
	}
	return nil
}

func (m *Flow) GetRawPacketsCaptured() int64 {
	if m != nil {
		return m.RawPacketsCaptured
	}
	return 0
}

func (m *Flow) GetFinishType() FlowFinishType {
	if m != nil {
		return m.FinishType
	}
	return FlowFinishType_NOT_FINISHED
}

type FlowSet struct {
	Flows []*Flow `protobuf:"bytes,1,rep,name=Flows,proto3" json:"Flows,omitempty"`
	Start int64   `protobuf:"varint,2,opt,name=Start,proto3" json:"Start"`
	End   int64   `protobuf:"varint,3,opt,name=End,proto3" json:"End"`
}

func (m *FlowSet) Reset()         { *m = FlowSet{} }
func (m *FlowSet) String() string { return proto.CompactTextString(m) }
func (*FlowSet) ProtoMessage()    {}
func (*FlowSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{10}
}
func (m *FlowSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowSet.Merge(m, src)
}
func (m *FlowSet) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FlowSet) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowSet.DiscardUnknown(m)
}

var xxx_messageInfo_FlowSet proto.InternalMessageInfo

func (m *FlowSet) GetFlows() []*Flow {
	if m != nil {
		return m.Flows
	}
	return nil
}

func (m *FlowSet) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *FlowSet) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type FlowSearchReply struct {
	FlowSet *FlowSet `protobuf:"bytes,1,opt,name=FlowSet,proto3" json:"FlowSet,omitempty"`
}

func (m *FlowSearchReply) Reset()         { *m = FlowSearchReply{} }
func (m *FlowSearchReply) String() string { return proto.CompactTextString(m) }
func (*FlowSearchReply) ProtoMessage()    {}
func (*FlowSearchReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{11}
}
func (m *FlowSearchReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowSearchReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowSearchReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowSearchReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowSearchReply.Merge(m, src)
}
func (m *FlowSearchReply) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FlowSearchReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowSearchReply.DiscardUnknown(m)
}

var xxx_messageInfo_FlowSearchReply proto.InternalMessageInfo

func (m *FlowSearchReply) GetFlowSet() *FlowSet {
	if m != nil {
		return m.FlowSet
	}
	return nil
}

type TableQuery struct {
	Type  string               `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Query *filters.SearchQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *TableQuery) Reset()         { *m = TableQuery{} }
func (m *TableQuery) String() string { return proto.CompactTextString(m) }
func (*TableQuery) ProtoMessage()    {}
func (*TableQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{12}
}
func (m *TableQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableQuery.Merge(m, src)
}
func (m *TableQuery) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_TableQuery.DiscardUnknown(m)
}

var xxx_messageInfo_TableQuery proto.InternalMessageInfo

func (m *TableQuery) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *TableQuery) GetQuery() *filters.SearchQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

type TableReply struct {
	Status       int32    `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
	FlowSetBytes [][]byte `protobuf:"bytes,2,rep,name=FlowSetBytes,proto3" json:"FlowSetBytes,omitempty"`
}

func (m *TableReply) Reset()         { *m = TableReply{} }
func (m *TableReply) String() string { return proto.CompactTextString(m) }
func (*TableReply) ProtoMessage()    {}
func (*TableReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{13}
}
func (m *TableReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableReply.Merge(m, src)
}
func (m *TableReply) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TableReply.DiscardUnknown(m)
}

var xxx_messageInfo_TableReply proto.InternalMessageInfo

func (m *TableReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *TableReply) GetFlowSetBytes() [][]byte {
	if m != nil {
		return m.FlowSetBytes
	}
	return nil
}

func init() {
	proto.RegisterEnum("flow.FlowProtocol", FlowProtocol_name, FlowProtocol_value)
	proto.RegisterEnum("flow.FlowFinishType", FlowFinishType_name, FlowFinishType_value)
	proto.RegisterEnum("flow.ICMPType", ICMPType_name, ICMPType_value)
	proto.RegisterType((*FlowLayer)(nil), "flow.FlowLayer")
	proto.RegisterType((*TransportLayer)(nil), "flow.TransportLayer")
	proto.RegisterType((*ICMPLayer)(nil), "flow.ICMPLayer")
	proto.RegisterType((*FlowMetric)(nil), "flow.FlowMetric")
	proto.RegisterType((*RawPacket)(nil), "flow.RawPacket")
	proto.RegisterType((*IPMetric)(nil), "flow.IPMetric")
	proto.RegisterType((*TCPMetric)(nil), "flow.TCPMetric")
	proto.RegisterType((*Message)(nil), "flow.Message")
	proto.RegisterType((*Stats)(nil), "flow.Stats")
	proto.RegisterType((*Flow)(nil), "flow.Flow")
	proto.RegisterType((*FlowSet)(nil), "flow.FlowSet")
	proto.RegisterType((*FlowSearchReply)(nil), "flow.FlowSearchReply")
	proto.RegisterType((*TableQuery)(nil), "flow.TableQuery")
	proto.RegisterType((*TableReply)(nil), "flow.TableReply")
}

func init() { proto.RegisterFile("flow/flow.proto", fileDescriptor_3c1fa740027c1208) }

var fileDescriptor_3c1fa740027c1208 = []byte{
	// 1613 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x6e, 0x23, 0x49,
	0x15, 0x8e, 0x63, 0xc7, 0x3f, 0xc7, 0x89, 0xd3, 0x53, 0x9b, 0xd9, 0x6d, 0x0d, 0xc8, 0x9b, 0x35,
	0xb0, 0x13, 0x22, 0xd6, 0x41, 0x9e, 0x68, 0x91, 0xd0, 0xde, 0xf4, 0x5f, 0x36, 0xcd, 0x24, 0xed,
	0xde, 0xea, 0xf6, 0x80, 0xb8, 0xb1, 0x7a, 0xec, 0x1a, 0xc7, 0xc4, 0xe3, 0x36, 0xdd, 0x9d, 0x84,
	0xbc, 0x05, 0x12, 0x0f, 0xb0, 0x3c, 0x06, 0x8f, 0xc0, 0xe5, 0x5e, 0x72, 0x85, 0xd0, 0x8c, 0x90,
	0x80, 0x47, 0xe0, 0x0a, 0x9d, 0xfa, 0xe9, 0x6e, 0x3b, 0x61, 0x84, 0xc4, 0x4d, 0x52, 0xe7, 0xfb,
	0xce, 0x4f, 0x9d, 0x53, 0x5d, 0xe7, 0x94, 0x61, 0xff, 0xcd, 0x22, 0xbe, 0x3b, 0xc1, 0x3f, 0xfd,
	0x55, 0x12, 0x67, 0x31, 0xa9, 0xe1, 0xfa, 0xd9, 0xc1, 0x2c, 0x9e, 0xc5, 0x1c, 0x38, 0xc1, 0x95,
	0xe0, 0x9e, 0xb5, 0xa6, 0xcb, 0x54, 0x2e, 0x77, 0xa7, 0x57, 0x93, 0xd5, 0xed, 0xa9, 0x92, 0x6e,
	0x93, 0x64, 0x75, 0x3b, 0x90, 0xd2, 0xd3, 0x37, 0xf3, 0x45, 0xc6, 0x92, 0xf4, 0x44, 0xfe, 0x17,
	0x70, 0x6f, 0x06, 0xad, 0xb3, 0x45, 0x7c, 0x77, 0x11, 0xdd, 0xb3, 0x84, 0xf4, 0xa1, 0xe9, 0x23,
	0x3a, 0x89, 0x17, 0x7a, 0xe5, 0xb0, 0x72, 0xd4, 0x19, 0x90, 0x3e, 0xdf, 0x05, 0xaa, 0x28, 0x86,
	0xe6, 0x3a, 0x64, 0x17, 0x2a, 0x86, 0x5e, 0x3d, 0xac, 0x1c, 0xb5, 0x68, 0xc5, 0x40, 0xc9, 0xd4,
	0x6b, 0x42, 0x32, 0x49, 0x07, 0xb6, 0x5d, 0x5b, 0xdf, 0x39, 0xac, 0x1c, 0x55, 0xe9, 0xb6, 0x6b,
	0xf7, 0x16, 0xd0, 0x09, 0x93, 0x68, 0x99, 0xae, 0xe2, 0x24, 0xfb, 0x3f, 0xa2, 0x6d, 0x73, 0x87,
	0x2a, 0x5a, 0x55, 0x48, 0x2a, 0x5a, 0x2d, 0x8f, 0x16, 0x40, 0xcb, 0xb5, 0x2e, 0x7d, 0x11, 0xa8,
	0x07, 0xb5, 0xf0, 0x7e, 0xc5, 0x64, 0x90, 0x8e, 0x08, 0x82, 0x34, 0xa2, 0x94, 0x73, 0x84, 0x40,
	0xcd, 0x8a, 0xa7, 0x8c, 0xfb, 0xdf, 0xa3, 0x7c, 0x2d, 0x9d, 0x56, 0x39, 0x82, 0x4e, 0xff, 0x54,
	0x01, 0xc0, 0xbd, 0x5d, 0xb2, 0x2c, 0x99, 0x4f, 0xc8, 0xf7, 0xa1, 0x65, 0x98, 0x7e, 0x34, 0xb9,
	0x66, 0x59, 0x2a, 0xf7, 0x55, 0x00, 0x44, 0x87, 0x86, 0x61, 0x9a, 0xf7, 0x19, 0x4b, 0xe5, 0x2e,
	0x95, 0x88, 0x76, 0xa6, 0xa1, 0xec, 0xc4, 0x96, 0x0b, 0x00, 0xed, 0x4c, 0x43, 0xd8, 0x89, 0xe2,
	0x29, 0x91, 0x1c, 0xc0, 0x4e, 0x90, 0x45, 0x49, 0xa6, 0xd7, 0x39, 0x2e, 0x04, 0xdc, 0xf8, 0x45,
	0x94, 0x66, 0x7a, 0x83, 0x83, 0x7c, 0x4d, 0x34, 0xa8, 0xd2, 0x30, 0xd4, 0x9b, 0x1c, 0xc2, 0x65,
	0xef, 0xdb, 0x0a, 0xb4, 0x68, 0x74, 0x27, 0x82, 0xe0, 0x0e, 0xc2, 0xf9, 0x5b, 0x96, 0x66, 0xd1,
	0xdb, 0x15, 0xaf, 0x4a, 0x95, 0x16, 0x00, 0xc6, 0x71, 0x97, 0x53, 0xf6, 0x3b, 0x99, 0x93, 0x10,
	0x30, 0x8e, 0x1d, 0x65, 0x11, 0x4f, 0x66, 0x97, 0xf2, 0x35, 0xf9, 0x05, 0x34, 0x2f, 0xe6, 0xcb,
	0x6b, 0x5e, 0x5c, 0x4c, 0x64, 0xcf, 0xec, 0xff, 0xfb, 0xaf, 0x9f, 0x1e, 0xcf, 0xe6, 0xd9, 0xd5,
	0xcd, 0xeb, 0xfe, 0x24, 0x7e, 0x7b, 0x32, 0x8b, 0xe3, 0xd9, 0x82, 0x9d, 0xcc, 0xe2, 0x15, 0x8f,
	0x7c, 0xb2, 0xc0, 0x03, 0x49, 0xfb, 0xca, 0x8a, 0xe6, 0xf6, 0x3d, 0x1f, 0x9a, 0xae, 0x5f, 0x54,
	0xf6, 0x2c, 0x89, 0x66, 0x6f, 0xd9, 0x32, 0x4b, 0xd5, 0xfe, 0x72, 0x80, 0x7c, 0x0e, 0x1d, 0x25,
	0x38, 0x49, 0x12, 0x27, 0xaa, 0xf8, 0x1b, 0x68, 0xef, 0x0f, 0x75, 0x68, 0x85, 0x96, 0xf2, 0xd9,
	0x05, 0x30, 0xcc, 0xe0, 0x7e, 0x29, 0x4a, 0x28, 0x9c, 0x96, 0x10, 0xe4, 0x4d, 0x23, 0xe7, 0x85,
	0xc7, 0x12, 0x42, 0x9e, 0x41, 0x93, 0x6b, 0x87, 0xe1, 0x85, 0xfc, 0x24, 0x72, 0x19, 0x39, 0xae,
	0x89, 0x5c, 0x4d, 0x70, 0x4a, 0x16, 0x71, 0xcf, 0xe6, 0xd2, 0xef, 0x8e, 0x8a, 0xab, 0x10, 0x11,
	0x37, 0xe7, 0xeb, 0x2a, 0x6e, 0x99, 0x37, 0x4c, 0x9a, 0x66, 0x82, 0x6f, 0x28, 0x7b, 0x85, 0x08,
	0xfb, 0x9c, 0x6f, 0x2a, 0xfb, 0x9c, 0xff, 0x29, 0x7c, 0x64, 0x98, 0x01, 0xe3, 0x85, 0x19, 0xde,
	0x64, 0xc3, 0x37, 0xc3, 0x64, 0xca, 0x12, 0xbd, 0xc5, 0x15, 0x1f, 0xa3, 0xc8, 0x31, 0x68, 0x39,
	0x1c, 0x5c, 0xcf, 0x57, 0x2b, 0x36, 0xd5, 0x81, 0xab, 0x3f, 0xc0, 0xc9, 0x29, 0x3c, 0xdd, 0xc4,
	0xc4, 0xb7, 0xdb, 0xe6, 0x06, 0x8f, 0x93, 0xeb, 0x37, 0x67, 0xf7, 0x03, 0x37, 0x67, 0x6f, 0xfd,
	0xe6, 0x88, 0x33, 0x8c, 0xee, 0x44, 0xae, 0x9d, 0xfc, 0x0c, 0x25, 0x22, 0xcf, 0x28, 0xba, 0x73,
	0x96, 0x53, 0x7d, 0x9f, 0xb3, 0xb9, 0x8c, 0x75, 0x30, 0x8d, 0x87, 0x75, 0xd0, 0x44, 0x1d, 0x1e,
	0xa1, 0xb0, 0x0e, 0x39, 0xac, 0xea, 0xf0, 0x44, 0xd4, 0x61, 0x13, 0xc7, 0x3a, 0x6c, 0x62, 0x22,
	0x03, 0x22, 0xea, 0xf0, 0x28, 0xb9, 0xde, 0x09, 0x3e, 0xfa, 0x40, 0x27, 0x38, 0x58, 0xef, 0x04,
	0xe2, 0x5b, 0x55, 0x75, 0x78, 0x9a, 0x7f, 0xab, 0xa5, 0x3a, 0x70, 0x09, 0xeb, 0xf0, 0xb1, 0xa8,
	0x83, 0x92, 0x7b, 0x1e, 0x34, 0x2e, 0x59, 0x9a, 0x46, 0x33, 0x46, 0x0e, 0x61, 0x07, 0xdb, 0x19,
	0x5e, 0xb1, 0xea, 0x51, 0x7b, 0x00, 0x45, 0xf7, 0xa5, 0x82, 0x20, 0x9f, 0xf1, 0x96, 0x23, 0xdb,
	0x5b, 0x7b, 0xd0, 0x16, 0x1a, 0x1c, 0xa2, 0x82, 0xe9, 0xfd, 0xbd, 0x22, 0x75, 0x30, 0x1b, 0x2b,
	0x5a, 0x65, 0x37, 0x09, 0x73, 0x6d, 0x7e, 0xc1, 0x5a, 0xb4, 0x00, 0xf8, 0x9d, 0x5e, 0xc4, 0x77,
	0x56, 0x7c, 0xb3, 0x54, 0xd7, 0xab, 0x00, 0xc8, 0x21, 0xb4, 0x51, 0xb0, 0x93, 0x98, 0x97, 0x59,
	0x74, 0xcc, 0x32, 0x44, 0x7e, 0x02, 0x4f, 0x5e, 0xb2, 0x64, 0xc9, 0x16, 0x65, 0x3d, 0xd1, 0x3d,
	0x1f, 0x12, 0xd8, 0x23, 0x64, 0x19, 0x95, 0xaa, 0xb8, 0x79, 0x1b, 0x28, 0x39, 0x82, 0x7d, 0x89,
	0x50, 0x36, 0x61, 0xf3, 0x5b, 0x36, 0x95, 0x57, 0x70, 0x13, 0xee, 0x7d, 0xdb, 0x80, 0x1a, 0x46,
	0xc0, 0x46, 0x38, 0x1a, 0xe5, 0x19, 0xf2, 0x35, 0x1e, 0x08, 0x1f, 0x35, 0xa9, 0x1f, 0x65, 0x57,
	0x3c, 0xbb, 0x16, 0x2d, 0x21, 0x98, 0x9e, 0xb1, 0x5a, 0x2d, 0xe6, 0x93, 0x28, 0x9b, 0xc7, 0x4b,
	0x39, 0x32, 0xcb, 0x10, 0xf9, 0x01, 0xd4, 0xb0, 0x15, 0xf2, 0x93, 0x6e, 0x0f, 0xf6, 0x8b, 0xa3,
	0xe0, 0x5e, 0x28, 0x27, 0xc9, 0x8f, 0xa1, 0xe1, 0xb1, 0xec, 0x2e, 0x4e, 0xae, 0xf9, 0xa1, 0x3f,
	0xa2, 0xa7, 0x78, 0x32, 0x80, 0x56, 0x3e, 0x6e, 0xf9, 0x37, 0xd0, 0x1e, 0x1c, 0x08, 0xe5, 0xf5,
	0x29, 0x4c, 0x0b, 0x35, 0xdc, 0x03, 0x4e, 0x45, 0xfd, 0x93, 0xb2, 0xef, 0x7c, 0x8c, 0x52, 0x4e,
	0x92, 0xe7, 0x50, 0xb7, 0xcf, 0x2d, 0xff, 0xf6, 0x54, 0xff, 0x47, 0x83, 0xeb, 0x75, 0xfa, 0xb2,
	0xa9, 0x0b, 0x98, 0x4a, 0x9a, 0x74, 0xa1, 0x6a, 0x7b, 0x81, 0xfe, 0xcf, 0x86, 0xfc, 0x74, 0x94,
	0x96, 0x17, 0x50, 0x24, 0xd0, 0xd1, 0x2b, 0x4a, 0xfd, 0xdb, 0x81, 0xfe, 0xaf, 0x0d, 0x47, 0x02,
	0xa6, 0x92, 0x26, 0x5f, 0x81, 0x86, 0x53, 0x6d, 0xb4, 0x9a, 0x46, 0x19, 0x13, 0xdd, 0x5c, 0xff,
	0x94, 0x5b, 0x68, 0x45, 0xfa, 0x02, 0xa7, 0x0f, 0x34, 0xc9, 0x11, 0xd4, 0xa5, 0xcd, 0xe1, 0x7f,
	0xb1, 0x91, 0x3c, 0xf9, 0xa2, 0x34, 0x2e, 0xf4, 0xcf, 0xcb, 0x35, 0xc8, 0x61, 0x5a, 0x1a, 0x28,
	0xc7, 0xc5, 0xc0, 0xd2, 0x9f, 0xcb, 0x04, 0x44, 0xc5, 0x94, 0x72, 0x31, 0xd0, 0xf2, 0xd1, 0x0d,
	0x8f, 0x8d, 0xee, 0x76, 0x69, 0x74, 0x77, 0x01, 0xc2, 0x24, 0x9a, 0x5c, 0xcf, 0x97, 0x33, 0xd7,
	0xd6, 0x07, 0xe2, 0x4b, 0x2a, 0x10, 0xd2, 0x83, 0xdd, 0x8b, 0x17, 0x25, 0x8d, 0x17, 0x5c, 0x63,
	0x0d, 0x43, 0x1f, 0x7e, 0x94, 0xb0, 0x65, 0xc6, 0xbf, 0xd3, 0xba, 0xf0, 0x51, 0x20, 0xd8, 0x58,
	0xbc, 0x78, 0xca, 0x42, 0xd7, 0xd6, 0x3f, 0xe3, 0xa4, 0x12, 0xd7, 0xaf, 0x70, 0x6f, 0xf3, 0x0a,
	0xff, 0x0c, 0x3a, 0xb8, 0xc7, 0xfc, 0x1d, 0x91, 0xea, 0x3f, 0xe4, 0x8d, 0x43, 0x56, 0x29, 0xc7,
	0xe9, 0x86, 0x1a, 0xe9, 0x03, 0x29, 0x24, 0xe9, 0x6f, 0xaa, 0xff, 0x88, 0xa7, 0xfd, 0x08, 0x43,
	0x4e, 0x01, 0xce, 0xe6, 0xcb, 0x79, 0x7a, 0xc5, 0x5f, 0x16, 0x5f, 0xf1, 0x67, 0xdb, 0x41, 0x71,
	0x6e, 0x05, 0x47, 0x4b, 0x7a, 0xbd, 0x00, 0x1a, 0xc8, 0x06, 0x2c, 0xfb, 0x1f, 0x3a, 0x5b, 0x7e,
	0x22, 0xdb, 0xe5, 0x13, 0xd1, 0xa0, 0x8a, 0x3d, 0x53, 0xb4, 0x1f, 0x5c, 0xf6, 0x7e, 0x0e, 0xfb,
	0xc2, 0x69, 0x94, 0x4c, 0xae, 0x28, 0x5b, 0x2d, 0xee, 0xc9, 0xf3, 0x3c, 0x0e, 0xef, 0x01, 0xed,
	0xc1, 0x5e, 0xe1, 0x3e, 0x60, 0x19, 0x55, 0x6c, 0xef, 0x02, 0x20, 0x8c, 0x5e, 0x2f, 0xd8, 0x37,
	0x37, 0x2c, 0xb9, 0xc7, 0xd3, 0xce, 0x5f, 0xa1, 0x2d, 0xf9, 0xea, 0x3c, 0x86, 0x9d, 0xdf, 0x22,
	0x29, 0xfb, 0xeb, 0x41, 0x5f, 0x3d, 0xce, 0x45, 0x3c, 0x6e, 0x48, 0x85, 0x4a, 0xef, 0x5c, 0x7a,
	0x13, 0x9b, 0xf8, 0x18, 0xea, 0xd8, 0x75, 0x6f, 0xc4, 0xfb, 0x68, 0x87, 0x4a, 0x09, 0xbf, 0x0f,
	0x19, 0x5e, 0x4c, 0x8e, 0xed, 0xc3, 0xea, 0xd1, 0x2e, 0x5d, 0xc3, 0x8e, 0xa7, 0x42, 0xa7, 0xf4,
	0xb0, 0x6e, 0x3a, 0xe1, 0xb9, 0x43, 0x3d, 0x27, 0xd4, 0xb6, 0x48, 0x13, 0x6a, 0xae, 0xff, 0xea,
	0x54, 0xab, 0x90, 0x06, 0x54, 0x43, 0xcb, 0xd7, 0xb6, 0x71, 0x31, 0xb2, 0x7d, 0xad, 0x8a, 0x5c,
	0x60, 0x85, 0xbe, 0x56, 0x93, 0x5a, 0x5f, 0x6a, 0x3b, 0x04, 0xa0, 0x8e, 0x8d, 0xe1, 0xd5, 0xa9,
	0x56, 0xcf, 0xd7, 0x5f, 0x6a, 0x8d, 0x63, 0x17, 0x3a, 0xeb, 0x87, 0x45, 0x34, 0xd8, 0xf5, 0x86,
	0xe1, 0xf8, 0xcc, 0xf5, 0xdc, 0xe0, 0xdc, 0xb1, 0xb5, 0x2d, 0xd2, 0x86, 0x46, 0xe8, 0x5e, 0x3a,
	0xc3, 0x51, 0xa8, 0x55, 0xb8, 0x60, 0xf9, 0x48, 0x6b, 0xdb, 0x4a, 0xa0, 0x41, 0xa8, 0x55, 0x8f,
	0xdf, 0x55, 0xa0, 0xa9, 0xde, 0xeb, 0xc8, 0x8c, 0xbc, 0x97, 0xde, 0xf0, 0x97, 0x9e, 0xb6, 0x45,
	0xbe, 0x07, 0x9f, 0xd8, 0x4e, 0x10, 0xba, 0x9e, 0x11, 0xba, 0x43, 0x6f, 0x3c, 0xf2, 0xa8, 0x63,
	0x58, 0xe7, 0x86, 0x79, 0xe1, 0x68, 0x15, 0xdc, 0xa3, 0x63, 0x9d, 0x0f, 0xb5, 0x6d, 0xcc, 0xd0,
	0x73, 0xdc, 0xaf, 0xcf, 0xcd, 0x21, 0xd5, 0xaa, 0xb8, 0x0f, 0xc3, 0xb6, 0xa9, 0x13, 0x04, 0xe3,
	0x4b, 0x23, 0x78, 0x29, 0xb3, 0xf1, 0xce, 0x86, 0xda, 0x0e, 0x79, 0x0a, 0x4f, 0x7c, 0x83, 0x1a,
	0x97, 0x4e, 0xe8, 0xd0, 0xb1, 0x4f, 0x87, 0xe6, 0x85, 0x73, 0xa9, 0xd5, 0xd1, 0x01, 0x75, 0x6c,
	0x97, 0x3a, 0x56, 0xa8, 0x35, 0x30, 0x4d, 0x3a, 0x1c, 0x85, 0x0e, 0xd5, 0x9a, 0xe4, 0x09, 0xec,
	0x05, 0xc3, 0x11, 0xb5, 0x9c, 0xf1, 0x37, 0x23, 0xc7, 0xb3, 0xce, 0xb5, 0x16, 0x42, 0x98, 0xd5,
	0xd8, 0xf9, 0x95, 0xe5, 0x38, 0xb6, 0x63, 0x6b, 0x40, 0xf6, 0xa0, 0x85, 0x50, 0x10, 0x1a, 0x97,
	0xbe, 0xd6, 0x26, 0x04, 0x3a, 0xbe, 0x61, 0xbd, 0x74, 0xc2, 0x71, 0x38, 0x1c, 0x8e, 0x4d, 0xf7,
	0x6b, 0x6d, 0xd7, 0x74, 0xfe, 0xfc, 0xae, 0x5b, 0xf9, 0xee, 0x5d, 0xb7, 0xf2, 0xb7, 0x77, 0xdd,
	0xad, 0xdf, 0xbf, 0xef, 0x6e, 0xfd, 0xf1, 0x7d, 0xb7, 0xf2, 0xdd, 0xfb, 0xee, 0xd6, 0x5f, 0xde,
	0x77, 0xb7, 0x7e, 0xfd, 0xbc, 0xf4, 0xa8, 0x4e, 0xaf, 0xef, 0xa7, 0xf3, 0x5b, 0xf6, 0xc5, 0x2a,
	0x89, 0x7f, 0xc3, 0x26, 0x99, 0x92, 0xf9, 0x0f, 0xc6, 0xd7, 0x75, 0xfe, 0xbb, 0xee, 0xc5, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0xe5, 0xd2, 0xc8, 0x77, 0x44, 0x0e, 0x00, 0x00,
}

func (m *FlowLayer) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.B) > 0 {
		i -= len(m.B)
		copy(dAtA[i:], m.B)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.B)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.A) > 0 {
		i -= len(m.A)
		copy(dAtA[i:], m.A)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.A)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Protocol != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransportLayer) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransportLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransportLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x20
	}
	if m.B != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x18
	}
	if m.A != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x10
	}
	if m.Protocol != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ICMPLayer) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICMPLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x18
	}
	if m.Code != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowMetric) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RTT != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.RTT))
		i--
		dAtA[i] = 0x40
	}
	if m.Last != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Last))
		i--
		dAtA[i] = 0x38
	}
	if m.Start != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x30
	}
	if m.BABytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BABytes))
		i--
		dAtA[i] = 0x28
	}
	if m.BAPackets != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BAPackets))
		i--
		dAtA[i] = 0x20
	}
	if m.ABBytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.ABPackets != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABPackets))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *RawPacket) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LinkType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.LinkType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPMetric) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FragmentErrors != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.FragmentErrors))
		i--
		dAtA[i] = 0x10
	}
	if m.Fragments != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Fragments))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TCPMetric) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BASawEnd != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASawEnd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.BASawStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASawStart))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.BABytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BABytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.BAPackets != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BAPackets))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.BASegmentSkippedBytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASegmentSkippedBytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.BASegmentSkipped != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASegmentSkipped))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.BASegmentOutOfOrder != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASegmentOutOfOrder))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ABSawEnd != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSawEnd))
		i--
		dAtA[i] = 0x78
	}
	if m.ABSawStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSawStart))
		i--
		dAtA[i] = 0x70
	}
	if m.ABBytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABBytes))
		i--
		dAtA[i] = 0x68
	}
	if m.ABPackets != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABPackets))
		i--
		dAtA[i] = 0x60
	}
	if m.ABSegmentSkippedBytes != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSegmentSkippedBytes))
		i--
		dAtA[i] = 0x58
	}
	if m.ABSegmentSkipped != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSegmentSkipped))
		i--
		dAtA[i] = 0x50
	}
	if m.ABSegmentOutOfOrder != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSegmentOutOfOrder))
		i--
		dAtA[i] = 0x48
	}
	if m.BARstStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BARstStart))
		i--
		dAtA[i] = 0x40
	}
	if m.ABRstStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABRstStart))
		i--
		dAtA[i] = 0x38
	}
	if m.BAFinStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BAFinStart))
		i--
		dAtA[i] = 0x30
	}
	if m.ABFinStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABFinStart))
		i--
		dAtA[i] = 0x28
	}
	if m.BASynTTL != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASynTTL))
		i--
		dAtA[i] = 0x20
	}
	if m.ABSynTTL != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSynTTL))
		i--
		dAtA[i] = 0x18
	}
	if m.BASynStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.BASynStart))
		i--
		dAtA[i] = 0x10
	}
	if m.ABSynStart != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.ABSynStart))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PacketsReceived != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.PacketsReceived))
		i--
		dAtA[i] = 0x30
	}
	if m.PacketsDropped != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.PacketsDropped))
		i--
		dAtA[i] = 0x28
	}
	if m.KernelFlowDropped != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.KernelFlowDropped))
		i--
		dAtA[i] = 0x20
	}
	if m.FlowDropped != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.FlowDropped))
		i--
		dAtA[i] = 0x18
	}
	if m.FlowCount != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.FlowCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CaptureID) > 0 {
		i -= len(m.CaptureID)
		copy(dAtA[i:], m.CaptureID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.CaptureID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VRRPv2 != nil {
		{
			size, err := m.VRRPv2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd2
	}
	if m.DNS != nil {
		{
			size, err := m.DNS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.DHCPv4 != nil {
		{
			size, err := m.DHCPv4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.FinishType != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.FinishType))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if len(m.L3TrackingID) > 0 {
		i -= len(m.L3TrackingID)
		copy(dAtA[i:], m.L3TrackingID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.L3TrackingID)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if len(m.TrackingID) > 0 {
		i -= len(m.TrackingID)
		copy(dAtA[i:], m.TrackingID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.TrackingID)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.IPMetric != nil {
		{
			size, err := m.IPMetric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.TCPMetric != nil {
		{
			size, err := m.TCPMetric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.RawPacketsCaptured != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.RawPacketsCaptured))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.LastRawPackets) > 0 {
		for iNdEx := len(m.LastRawPackets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LastRawPackets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.CaptureID) > 0 {
		i -= len(m.CaptureID)
		copy(dAtA[i:], m.CaptureID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.CaptureID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.NodeTID) > 0 {
		i -= len(m.NodeTID)
		copy(dAtA[i:], m.NodeTID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.NodeTID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.Metric != nil {
		{
			size, err := m.Metric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.LastUpdateMetric != nil {
		{
			size, err := m.LastUpdateMetric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.ICMP != nil {
		{
			size, err := m.ICMP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Transport != nil {
		{
			size, err := m.Transport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Last != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Last))
		i--
		dAtA[i] = 0x58
	}
	if m.Start != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ParentUUID) > 0 {
		i -= len(m.ParentUUID)
		copy(dAtA[i:], m.ParentUUID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ParentUUID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Application) > 0 {
		i -= len(m.Application)
		copy(dAtA[i:], m.Application)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Application)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LayersPath) > 0 {
		i -= len(m.LayersPath)
		copy(dAtA[i:], m.LayersPath)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.LayersPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UUID) > 0 {
		i -= len(m.UUID)
		copy(dAtA[i:], m.UUID)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.UUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowSet) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Flows) > 0 {
		for iNdEx := len(m.Flows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Flows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowSearchReply) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowSearchReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowSearchReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowSet != nil {
		{
			size, err := m.FlowSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableQuery) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableReply) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FlowSetBytes) > 0 {
		for iNdEx := len(m.FlowSetBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FlowSetBytes[iNdEx])
			copy(dAtA[i:], m.FlowSetBytes[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.FlowSetBytes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FlowLayer) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovFlow(uint64(m.Protocol))
	}
	l = len(m.A)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.B)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovFlow(uint64(m.ID))
	}
	return n
}

func (m *TransportLayer) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovFlow(uint64(m.Protocol))
	}
	if m.A != 0 {
		n += 1 + sovFlow(uint64(m.A))
	}
	if m.B != 0 {
		n += 1 + sovFlow(uint64(m.B))
	}
	if m.ID != 0 {
		n += 1 + sovFlow(uint64(m.ID))
	}
	return n
}

func (m *ICMPLayer) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFlow(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovFlow(uint64(m.Code))
	}
	if m.ID != 0 {
		n += 1 + sovFlow(uint64(m.ID))
	}
	return n
}

func (m *FlowMetric) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ABPackets != 0 {
		n += 1 + sovFlow(uint64(m.ABPackets))
	}
	if m.ABBytes != 0 {
		n += 1 + sovFlow(uint64(m.ABBytes))
	}
	if m.BAPackets != 0 {
		n += 1 + sovFlow(uint64(m.BAPackets))
	}
	if m.BABytes != 0 {
		n += 1 + sovFlow(uint64(m.BABytes))
	}
	if m.Start != 0 {
		n += 1 + sovFlow(uint64(m.Start))
	}
	if m.Last != 0 {
		n += 1 + sovFlow(uint64(m.Last))
	}
	if m.RTT != 0 {
		n += 1 + sovFlow(uint64(m.RTT))
	}
	return n
}

func (m *RawPacket) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovFlow(uint64(m.Timestamp))
	}
	if m.Index != 0 {
		n += 1 + sovFlow(uint64(m.Index))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.LinkType != 0 {
		n += 1 + sovFlow(uint64(m.LinkType))
	}
	return n
}

func (m *IPMetric) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fragments != 0 {
		n += 1 + sovFlow(uint64(m.Fragments))
	}
	if m.FragmentErrors != 0 {
		n += 1 + sovFlow(uint64(m.FragmentErrors))
	}
	return n
}

func (m *TCPMetric) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ABSynStart != 0 {
		n += 1 + sovFlow(uint64(m.ABSynStart))
	}
	if m.BASynStart != 0 {
		n += 1 + sovFlow(uint64(m.BASynStart))
	}
	if m.ABSynTTL != 0 {
		n += 1 + sovFlow(uint64(m.ABSynTTL))
	}
	if m.BASynTTL != 0 {
		n += 1 + sovFlow(uint64(m.BASynTTL))
	}
	if m.ABFinStart != 0 {
		n += 1 + sovFlow(uint64(m.ABFinStart))
	}
	if m.BAFinStart != 0 {
		n += 1 + sovFlow(uint64(m.BAFinStart))
	}
	if m.ABRstStart != 0 {
		n += 1 + sovFlow(uint64(m.ABRstStart))
	}
	if m.BARstStart != 0 {
		n += 1 + sovFlow(uint64(m.BARstStart))
	}
	if m.ABSegmentOutOfOrder != 0 {
		n += 1 + sovFlow(uint64(m.ABSegmentOutOfOrder))
	}
	if m.ABSegmentSkipped != 0 {
		n += 1 + sovFlow(uint64(m.ABSegmentSkipped))
	}
	if m.ABSegmentSkippedBytes != 0 {
		n += 1 + sovFlow(uint64(m.ABSegmentSkippedBytes))
	}
	if m.ABPackets != 0 {
		n += 1 + sovFlow(uint64(m.ABPackets))
	}
	if m.ABBytes != 0 {
		n += 1 + sovFlow(uint64(m.ABBytes))
	}
	if m.ABSawStart != 0 {
		n += 1 + sovFlow(uint64(m.ABSawStart))
	}
	if m.ABSawEnd != 0 {
		n += 1 + sovFlow(uint64(m.ABSawEnd))
	}
	if m.BASegmentOutOfOrder != 0 {
		n += 2 + sovFlow(uint64(m.BASegmentOutOfOrder))
	}
	if m.BASegmentSkipped != 0 {
		n += 2 + sovFlow(uint64(m.BASegmentSkipped))
	}
	if m.BASegmentSkippedBytes != 0 {
		n += 2 + sovFlow(uint64(m.BASegmentSkippedBytes))
	}
	if m.BAPackets != 0 {
		n += 2 + sovFlow(uint64(m.BAPackets))
	}
	if m.BABytes != 0 {
		n += 2 + sovFlow(uint64(m.BABytes))
	}
	if m.BASawStart != 0 {
		n += 2 + sovFlow(uint64(m.BASawStart))
	}
	if m.BASawEnd != 0 {
		n += 2 + sovFlow(uint64(m.BASawEnd))
	}
	return n
}

func (m *Message) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, e := range m.Flows {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaptureID)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.FlowCount != 0 {
		n += 1 + sovFlow(uint64(m.FlowCount))
	}
	if m.FlowDropped != 0 {
		n += 1 + sovFlow(uint64(m.FlowDropped))
	}
	if m.KernelFlowDropped != 0 {
		n += 1 + sovFlow(uint64(m.KernelFlowDropped))
	}
	if m.PacketsDropped != 0 {
		n += 1 + sovFlow(uint64(m.PacketsDropped))
	}
	if m.PacketsReceived != 0 {
		n += 1 + sovFlow(uint64(m.PacketsReceived))
	}
	return n
}

func (m *Flow) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UUID)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.LayersPath)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Application)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ParentUUID)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovFlow(uint64(m.Start))
	}
	if m.Last != 0 {
		n += 1 + sovFlow(uint64(m.Last))
	}
	if m.Link != nil {
		l = m.Link.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.Transport != nil {
		l = m.Transport.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.ICMP != nil {
		l = m.ICMP.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.LastUpdateMetric != nil {
		l = m.LastUpdateMetric.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.Metric != nil {
		l = m.Metric.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	l = len(m.NodeTID)
	if l > 0 {
		n += 2 + l + sovFlow(uint64(l))
	}
	l = len(m.CaptureID)
	if l > 0 {
		n += 2 + l + sovFlow(uint64(l))
	}
	if len(m.LastRawPackets) > 0 {
		for _, e := range m.LastRawPackets {
			l = e.ProtoSize()
			n += 2 + l + sovFlow(uint64(l))
		}
	}
	if m.RawPacketsCaptured != 0 {
		n += 2 + sovFlow(uint64(m.RawPacketsCaptured))
	}
	if m.TCPMetric != nil {
		l = m.TCPMetric.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.IPMetric != nil {
		l = m.IPMetric.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	l = len(m.TrackingID)
	if l > 0 {
		n += 2 + l + sovFlow(uint64(l))
	}
	l = len(m.L3TrackingID)
	if l > 0 {
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.FinishType != 0 {
		n += 2 + sovFlow(uint64(m.FinishType))
	}
	if m.DHCPv4 != nil {
		l = m.DHCPv4.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.DNS != nil {
		l = m.DNS.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	if m.VRRPv2 != nil {
		l = m.VRRPv2.ProtoSize()
		n += 2 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *FlowSet) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Flows) > 0 {
		for _, e := range m.Flows {
			l = e.ProtoSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Start != 0 {
		n += 1 + sovFlow(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovFlow(uint64(m.End))
	}
	return n
}

func (m *FlowSearchReply) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowSet != nil {
		l = m.FlowSet.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *TableQuery) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *TableReply) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlow(uint64(m.Status))
	}
	if len(m.FlowSetBytes) > 0 {
		for _, b := range m.FlowSetBytes {
			l = len(b)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	return n
}

func sovFlow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= FlowProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.B = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransportLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransportLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransportLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= FlowProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMPLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ICMPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABPackets", wireType)
			}
			m.ABPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABPackets |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABBytes", wireType)
			}
			m.ABBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BAPackets", wireType)
			}
			m.BAPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BAPackets |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BABytes", wireType)
			}
			m.BABytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BABytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			m.Last = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Last |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTT", wireType)
			}
			m.RTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RTT |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkType", wireType)
			}
			m.LinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkType |= github_com_google_gopacket_layers.LinkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragments", wireType)
			}
			m.Fragments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fragments |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentErrors", wireType)
			}
			m.FragmentErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentErrors |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSynStart", wireType)
			}
			m.ABSynStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSynStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASynStart", wireType)
			}
			m.BASynStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASynStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSynTTL", wireType)
			}
			m.ABSynTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSynTTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASynTTL", wireType)
			}
			m.BASynTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASynTTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABFinStart", wireType)
			}
			m.ABFinStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABFinStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BAFinStart", wireType)
			}
			m.BAFinStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BAFinStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABRstStart", wireType)
			}
			m.ABRstStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABRstStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BARstStart", wireType)
			}
			m.BARstStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BARstStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSegmentOutOfOrder", wireType)
			}
			m.ABSegmentOutOfOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSegmentOutOfOrder |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSegmentSkipped", wireType)
			}
			m.ABSegmentSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSegmentSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSegmentSkippedBytes", wireType)
			}
			m.ABSegmentSkippedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSegmentSkippedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABPackets", wireType)
			}
			m.ABPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABPackets |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABBytes", wireType)
			}
			m.ABBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSawStart", wireType)
			}
			m.ABSawStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSawStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ABSawEnd", wireType)
			}
			m.ABSawEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ABSawEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASegmentOutOfOrder", wireType)
			}
			m.BASegmentOutOfOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASegmentOutOfOrder |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASegmentSkipped", wireType)
			}
			m.BASegmentSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASegmentSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASegmentSkippedBytes", wireType)
			}
			m.BASegmentSkippedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASegmentSkippedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BAPackets", wireType)
			}
			m.BAPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BAPackets |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BABytes", wireType)
			}
			m.BABytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BABytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASawStart", wireType)
			}
			m.BASawStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASawStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BASawEnd", wireType)
			}
			m.BASawEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BASawEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, &Flow{})
			if err := m.Flows[len(m.Flows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptureID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptureID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowCount", wireType)
			}
			m.FlowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowDropped", wireType)
			}
			m.FlowDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowDropped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelFlowDropped", wireType)
			}
			m.KernelFlowDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelFlowDropped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsDropped", wireType)
			}
			m.PacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsDropped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsReceived", wireType)
			}
			m.PacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsReceived |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayersPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LayersPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Application", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Application = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			m.Last = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Last |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &FlowLayer{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &FlowLayer{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &TransportLayer{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ICMP == nil {
				m.ICMP = &ICMPLayer{}
			}
			if err := m.ICMP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateMetric == nil {
				m.LastUpdateMetric = &FlowMetric{}
			}
			if err := m.LastUpdateMetric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &FlowMetric{}
			}
			if err := m.Metric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeTID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeTID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptureID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptureID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRawPackets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastRawPackets = append(m.LastRawPackets, &RawPacket{})
			if err := m.LastRawPackets[len(m.LastRawPackets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawPacketsCaptured", wireType)
			}
			m.RawPacketsCaptured = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawPacketsCaptured |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TCPMetric == nil {
				m.TCPMetric = &TCPMetric{}
			}
			if err := m.TCPMetric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPMetric == nil {
				m.IPMetric = &IPMetric{}
			}
			if err := m.IPMetric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackingID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3TrackingID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L3TrackingID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishType", wireType)
			}
			m.FinishType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishType |= FlowFinishType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DHCPv4 == nil {
				m.DHCPv4 = &layers.DHCPv4{}
			}
			if err := m.DHCPv4.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNS == nil {
				m.DNS = &layers.DNS{}
			}
			if err := m.DNS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VRRPv2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VRRPv2 == nil {
				m.VRRPv2 = &layers.VRRPv2{}
			}
			if err := m.VRRPv2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flows = append(m.Flows, &Flow{})
			if err := m.Flows[len(m.Flows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSearchReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSearchReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSearchReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowSet == nil {
				m.FlowSet = &FlowSet{}
			}
			if err := m.FlowSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &filters.SearchQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowSetBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowSetBytes = append(m.FlowSetBytes, make([]byte, postIndex-iNdEx))
			copy(m.FlowSetBytes[len(m.FlowSetBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlow = fmt.Errorf("proto: unexpected end of group")
)
